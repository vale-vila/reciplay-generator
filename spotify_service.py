import os
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials, SpotifyOAuth
from typing import List, Dict, Optional
from dotenv import load_dotenv
import time

class SpotifyService:
    def __init__(self, use_user_auth: bool = False):
        load_dotenv()
        
        # Get Spotify credentials from environment variables
        client_id = os.getenv("SPOTIFY_CLIENT_ID")
        client_secret = os.getenv("SPOTIFY_CLIENT_SECRET")
        redirect_uri = os.getenv("SPOTIFY_REDIRECT_URI")
        
        if not client_id or not client_secret:
            raise ValueError("SPOTIFY_CLIENT_ID and SPOTIFY_CLIENT_SECRET must be set in environment variables")
        
        if use_user_auth:
            # Initialize Spotify client with user authentication
            auth_manager = SpotifyOAuth(
                client_id=client_id,
                client_secret=client_secret,
                redirect_uri=redirect_uri,
                scope="playlist-modify-public playlist-modify-private",
                open_browser=True
            )
        else:
            # Initialize Spotify client with client credentials flow
            auth_manager = SpotifyClientCredentials(
                client_id=client_id,
                client_secret=client_secret
            )
            
        self.sp = spotipy.Spotify(auth_manager=auth_manager)
        
    def _extract_track_info(self, track: Dict) -> Dict:
        """Extract relevant information from a Spotify track object."""
        return {
            "id": track["id"],
            "name": track["name"],
            "artist": track["artists"][0]["name"],
            "album": track["album"]["name"],
            "preview_url": track["preview_url"]
        }
    
    def search_songs(self, song_list: List[str], max_retries: int = 3) -> List[Dict]:
        """
        Search for songs on Spotify and return track information.
        
        Args:
            song_list: List of song names (with or without artists)
            max_retries: Maximum number of retries for rate-limited requests
            
        Returns:
            List of dictionaries containing track information
        """
        found_tracks = []
        
        for song in song_list:
            retries = 0
            while retries < max_retries:
                try:
                    # Search for the song
                    results = self.sp.search(q=song, limit=1, type="track")
                    
                    if results["tracks"]["items"]:
                        track = results["tracks"]["items"][0]
                        found_tracks.append(self._extract_track_info(track))
                        print(f"✅ Found: {track['name']} by {track['artists'][0]['name']}")
                    else:
                        print(f"⚠️ No results found for: {song}")
                    
                    break  # Success, exit retry loop
                    
                except spotipy.exceptions.SpotifyException as e:
                    if e.http_status == 429:  # Rate limit error
                        retries += 1
                        if retries < max_retries:
                            wait_time = int(e.headers.get('Retry-After', 5))
                            print(f"Rate limited. Waiting {wait_time} seconds...")
                            time.sleep(wait_time)
                        else:
                            print(f"❌ Max retries reached for: {song}")
                    else:
                        print(f"❌ Error searching for {song}: {str(e)}")
                        break
                        
                except Exception as e:
                    print(f"❌ Unexpected error searching for {song}: {str(e)}")
                    break
            
            # Add a small delay between requests to avoid rate limits
            time.sleep(0.2)
        
        return found_tracks
    
    def create_playlist(self, user_id: str, playlist_name: str, track_ids: List[str]) -> Optional[Dict]:
        """
        Create a new playlist and add tracks to it.
        
        Args:
            user_id: Spotify user ID
            playlist_name: Name for the new playlist
            track_ids: List of Spotify track IDs to add
            
        Returns:
            Dictionary with playlist information or None if creation fails
        """
        try:
            # Create the playlist
            playlist = self.sp.user_playlist_create(
                user=user_id,
                name=playlist_name,
                public=False,
                description="Generated by Recipe Playlist Generator"
            )
            
            # Add tracks to the playlist
            if track_ids:
                self.sp.playlist_add_items(playlist["id"], track_ids)
            
            return {
                "id": playlist["id"],
                "name": playlist["name"],
                "url": playlist["external_urls"]["spotify"],
                "track_count": len(track_ids)
            }
            
        except spotipy.exceptions.SpotifyException as e:
            print(f"❌ Spotify API error creating playlist: {str(e)}")
            return None
        except Exception as e:
            print(f"❌ Unexpected error creating playlist: {str(e)}")
            return None
            
    def get_current_user(self) -> Optional[Dict]:
        """Get the current user's information."""
        try:
            return self.sp.current_user()
        except Exception as e:
            print(f"❌ Error getting current user: {str(e)}")
            return None